#+title: SCRS 2024 final task
#+SETUPFILE: /Users/visco/.config/doom/latex-standard-setup.org

* Introduction
This project involves the generation and analysis of algorithm implementations
in the GO programming language, leveraging state-of-the-art generative AI
models. The primary objective is to evaluate the quality and correctness of the
generated GO code through static analysis using the LiSA (Library for Static
Analysis) tool. The focus is on understanding the behavior of the code with
respect to two specific analysis domains chosen from a set of available domains.

** Objectives
*** Algorithm Specification and Generation
1. A given amount of algorithm specifications will be assigned across various
   categories such as array manipulation, sorting, and string manipulation.
2. For each specification, a generative AI language model will be used to
   produce the corresponding GO code.
*** Generative AI Models
1. The models selected for this task are:
   - CohereForAI/c4ai-command-r-plus
   - HuggingFaceH4/zephyr-orpo-141b-A35b-v0.1
2. These models will generate the GO code based on provided specifications. The
   code must be correctly implemented and capable of compilation without
   additional modification.
*** Static Analysis with LiSA
1. Each generated GO code will be analyzed using LiSA to evaluate its behavior
   in two chosen domains. The available domains include sign, parity, intervals,
   pentagons, prefix, suffix, tarsis, and taint.
2. The selected domains for this analysis will focus on understanding how the
   algorithms handle numerical properties (such as sign) and range checks (such
   as intervals).
*** Result Investigation
1. The results from LiSA will be thoroughly investigated to identify potential
   issues such as logical errors, out-of-bound accesses, incorrect handling of
   numerical properties, and other relevant concerns.
2. If the analysis is not meaningful due to missing main functions or other
   context-specific code, the models will be prompted to generate complete
   examples including main functions to ensure comprehensive analysis.

** Detailed steps of execution
*** Generative AI Process
1. Access the chosen models via the HuggingFace platform.
2. Input the system prompt designed for generating GO code.
3. Provide each model with the task specifications and collect the generated
   code.
4. Ensure the code is clean from any extraneous textual comments provided by the
   models.
*** Running LiSA Analysis
1. Use LiSA to perform static analysis on each generated GO script.
2. Select two domains suitable for each algorithm to provide a comprehensive
   understanding of the codeâ€™s behavior.
3. Document the analysis process and results for each script.
*** Investigation and Report Writing
1. Carefully investigate the results from LiSA.
2. Compile the findings into a coherent and detailed report, highlighting key insights and any issues detected during the analysis.


* Domains involved
* First AI model: c4ai-command-r-plus
** Array manipulation
The static analysis for the generated GO code using the LiSA tool was conducted with two domains: *Signs* and *Intervals*.
*** Binary Search
The binary search algorithm is an efficient method for finding an element within a sorted array. It operates by repeatedly dividing the search interval in half. The key steps are:
1. Initialize `left` to 0 and `right` to the last index of the array.
2. Calculate `mid` as the average of `left` and `right`.
3. If the middle element `arr[mid]` is equal to the target, return the index `mid`.
4. If `arr[mid]` is less than the target, adjust `left` to `mid + 1`.
5. If `arr[mid]` is greater than the target, adjust `right` to `mid - 1`.
6. Repeat steps 2-5 until `left` exceeds `right`, at which point the target is not present in the array, and return -1.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func binarySearch(arr []int, target int) int {
      left, right := 0, len(arr)-1
      for left <= right {
          mid := (left + right) / 2
          if arr[mid] == target {
              return mid
          } else if arr[mid] < target {
              left = mid + 1
          } else {
              right = mid - 1
          }
      }
      return -1
  }

  func main() {
      arr := []int{1, 2, 3, 4, 5}
      target := 4
      index := binarySearch(arr, target)
      fmt.Println(index)
  }
#+end_src

**** Graphical Output
[[./img/c4ai-command-r-plus/array-manipulation/binary-search.png]]

**** Intervals Domain analysis
- `arr`: The array is not modified, hence its elements remain as [1, 2, 3, 4, 5].
- `left`: Initially set to 0 and adjusted upwards, so the range is [0, 5].
- `right`: Initially set to 4 and adjusted downwards, so the range is [-2, 4].
- `mid`: Calculated as (left + right) / 2, so it depends on the ranges of `left` and `right`.
- `target`: Fixed at 4, so the range is [4, 4].

**** Signs Domain analysis
- `arr`: Not applicable as the domain focuses on numerical values.
- `left`: As `left` is incremented from 0, it remains positive or zero, so the sign is {0, +}.
- `right`: Starts at 4 and decrements, potentially becoming negative, so the sign is {0, +, -} (TOP).
- `mid`: Calculated as (left + right) / 2, can be positive or zero, so the sign is {0, +}.
- `target`: Fixed at 4, thus positive, so the sign is {+}.

*** Occurrence count
The occurrence count algorithm iterates through an array and counts the number of times a target value appears. The key steps are:
1. Initialize `count` to 0.
2. Iterate over each element in the array `arr`.
3. For each element `num`, check if it is equal to `target`.
4. If `num` equals `target`, increment `count`.
5. Return the value of `count` after the loop completes.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func occurrenceCount(arr []int, target int) int {
      count := 0
      for _, num := range arr {
          if num == target {
              count++
          }
      }
      return count
  }

  func main() {
      arr := []int{1, 2, 2, 3, 2, 4, 2, 5}
      target := 2
      fmt.Println(occurrenceCount(arr, target))
  }
#+end_src

**** Graphical Output
[[./img/c4ai-command-r-plus/array-manipulation/occurrence-count.png]]

**** Intervals Domain analysis
- `arr`: The array is not modified, hence its elements remain as [1, 2, 2, 3, 2, 4, 2, 5].
- `count`: Initially set to 0 and increments each time a match is found. The range depends on the number of matches, so it is [0, 8].
- `num`: Each element of the array `arr`, so the range is [1, 5].
- `target`: Fixed at 2, so the range is [2, 2].

**** Signs Domain analysis
- `arr`: Not applicable as the domain focuses on numerical values.
- `count`: Starts at 0 and increments, so the sign is {0, +}.
- `num`: Takes values from the array, which are positive, so the sign is {+}.
- `target`: Fixed at 2, thus positive, so the sign is {+}.

*** Count unique elements
The count unique elements algorithm utilizes a map to track unique values as it iterates through the array. The key steps are as follows:
1. Initialize a map `uniqueMap` to keep track of unique numbers.
2. Iterate over each element in the array `arr`.
3. For each element `num`, add it to `uniqueMap` with a value of `true`.
4. Return the number of unique keys in `uniqueMap` using `len()`.

**** Generated code
#+begin_src go
package main

import (
	"fmt"
)

func countUniqueElements(arr []int) int {
	uniqueMap := make(map[int]bool)
	for _, num := range arr {
		uniqueMap[num] = true
	}
	return len(uniqueMap)
}

func main() {
	arr := []int{1, 2, 2, 3, 4, 4, 5}
	fmt.Println(countUniqueElements(arr))
}
#+end_src
**** Graphical output
[[./img/c4ai-command-r-plus/array-manipulation/count-unique-elements.png]]

**** Intervals domain analysis
- `arr`: The input array can contain both unique and duplicate elements; in
  this case, it is `[1, 2, 2, 3, 4, 4, 5]`.
- `uniqueMap`: This map will contain only unique elements; thus, its length
  will vary depending on the number of unique elements found.
- Return Value: The function returns the count of unique elements, which
  ranges from `[0, n]`, where `n` is the length of the input array.

**** Signs domain analysis
- `arr`: Contains integers which can be both positive and negative, or zero,
  hence signs it TOP.
- `uniqueMap`: Not directly applicable as it stores unique keys.
- Return Value: The return value represents the count of unique integers and
  is always non-negative, so the sign set is {0, +}.


** Sorting
The static analysis for the generated GO code using the LiSA tool was conducted with two domains: *Parity* and *Intervals*.
*** Count sort
The count sort algorithm sorts an array by counting the occurrences of each unique value. The key steps are:
1. Find the maximum value in the array to determine the size of the count array.
2. Initialize a count array with zeros.
3. Count the occurrences of each element in the original array.
4. Use the count array to construct the sorted array.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func countSort(arr []int) []int {
      maxVal := 0
      for _, num := range arr {
          if num > maxVal {
              maxVal = num
          }
      }

      count := make([]int, maxVal+1)
      for _, num := range arr {
          count[num]++
      }

      sortedIndex := 0
      for i, freq := range count {
          for j := 0; j < freq; j++ {
              arr[sortedIndex] = i
              sortedIndex++
          }
      }

      return arr
  }

  func main() {
      arr := []int{2, 5, 3, 7, 2, 3, 6}
      fmt.Println(countSort(arr))
  }
#+end_src

**** Graphical output
[[./img/c4ai-command-r-plus/sorting/count-sort.png]]
**** Intervals domain analysis
- `arr`: The array is modified, and its elements are sorted. The initial range is [2, 7].
- `maxVal`: Initially set to 0 and updated to the maximum value in `arr`. The range is [0, 7].
- `count`: Array created with a size of `maxVal+1`, elements incremented based on occurrences in `arr`. Each element's range is [0, 3].
- `sortedIndex`: Used to insert elements into `arr`, incremented from 0. The range is [0, 7].
- `num`: Each element of the array `arr`, so the range is [2, 7].
- `i`: Index for iterating over `count`, ranging from 0 to `maxVal`. The range is [0, 7].
- `freq`: The value from the count array, representing the frequency of `i` in the original array. The range is [0, 3].
- `j`: Iterates from 0 to `freq`, ranges from [0, 3].

**** Parity domain analysis
- `arr`: Not applicable as the domain focuses on numerical values.
- `maxVal`: Represents the maximum value from `arr`, always positive. The parity is even or odd depending on `maxVal`.
- `count`: Elements incremented based on occurrences in `arr`. Values can be even or odd.
- `sortedIndex`: Increments from 0. The parity is {even}.
- `num`: Takes values from the array, either even or odd.
- `i`: Index iterating over `count`, can be even or odd.
- `freq`: The value from the count array, representing the frequency of `i`. Can be even or odd.
- `j`: Iterates from 0 to `freq`, parity depends on `freq`.

*** Heap sort
Heap sort is a comparison-based sorting algorithm that utilizes a binary heap data structure. The key steps are:
1. Build a max heap from the input data.
2. Swap the root of the heap with the last element of the heap.
3. Reduce the heap size by one and call `heapify` on the root.
4. Repeat steps 2-3 until the heap is reduced to a single element.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func heapify(arr []int, N int, i int) {
      largest := i
      left := 2*i + 1
      right := 2*i + 2

      if left < N && arr[left] > arr[largest] {
          largest = left
      }

      if right < N && arr[right] > arr[largest] {
          largest = right
      }

      if largest != i {
          arr[i], arr[largest] = arr[largest], arr[i]
          heapify(arr, N, largest)
      }
  }

  func heapSort(arr []int) {
      N := len(arr)

      for i := N / 2; i >= 0; i-- {
          heapify(arr, N, i)
      }

      for i := N - 1; i > 0; i-- {
          arr[i], arr[0] = arr[0], arr[i]
          heapify(arr, i, 0)
      }
  }

  func main() {
      arr := []int{12, 11, 13, 5, 6, 7}
      heapSort(arr)
      fmt.Println(arr)
  }
#+end_src
**** Graphical output
#+CAPTION: Main heapsort function
[[./img/c4ai-command-r-plus/sorting/heap-sort-heapsort.png]]

#+CAPTION: Heapify function
[[./img/c4ai-command-r-plus/sorting/heap-sort-heapify.png]]
**** Intervals domain analysis
- `arr`: The array is modified during heap construction and sorting. The initial range is [5, 13].
- `N`: Represents the length of the array, fixed at 6. The range is [6, 6].
- `i`: Used in the loops for building and sorting the heap. The range is [0, 6].
- `largest`: Used to track the largest value during heapify, varies between 0 and `N-1`. The range is [0, 6].
- `left`: Calculated as 2*i + 1, ranges from 1 to 13. The range is [1, 13].
- `right`: Calculated as 2*i + 2, ranges from 2 to 14. The range is [2, 14].
**** Parity domain analysis
- `arr`: Not applicable as the domain focuses on numerical values.
- `N`: Fixed at 6, hence the parity is even.
- `i`: Used in the loops, varies from 0 to `N-1`, hence the parity is {even, odd}.
- `largest`: Tracks the largest value during heapify, varies between 0 and `N-1`, hence the parity is {even, odd}.
- `left`: Calculated as 2*i + 1, hence the parity is {odd}.
- `right`: Calculated as 2*i + 2, hence the parity is {even}.
*** Insertion sort
Insertion sort is a simple and intuitive sorting algorithm that builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. The key steps are:
1. Iterate from the second element to the end of the array.
2. For each element, compare it with the elements before it and insert it into its correct position by shifting elements as necessary.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func insertionSort(arr []int) {
      for i := 1; i < len(arr); i++ {
          key := arr[i]
          j := i - 1
          for j >= 0 && arr[j] > key {
              arr[j+1] = arr[j]
              j--
          }
          arr[j+1] = key
      }
  }

  func main() {
      arr := []int{12, 11, 13, 5, 6}
      insertionSort(arr)
      fmt.Println(arr)
  }
#+end_src

**** Graphical output
[[./img/c4ai-command-r-plus/sorting/insertion-sort.png]]
**** Intervals domain analysis
- `arr`: The array is modified during sorting. The initial range is [5, 13].
- `i`: Used to iterate from 1 to the end of the array. The range is [1, 5].
- `key`: Takes the value of `arr[i]` during each iteration. The range is [5, 13].
- `j`: Used to iterate backwards from `i-1` to 0. The range is [0, 4].
**** Parity domain analysis
- `arr`: Not applicable as the domain focuses on numerical values.
- `i`: Used in the loop, varies from 1 to len(arr)-1, hence the parity is {odd}.
- `key`: Takes values from the array, can be either even or odd.
- `j`: Used to iterate backwards from `i-1` to 0, hence the parity is {even, odd}.
** String manipulation
The static analysis for the generated GO code using the LiSA tool was conducted with two domains: *Prefix* and *Suffix*.
*** Chars occurrences
The character occurrences algorithm counts the number of times a specific character appears in a string. The key steps are:
1. Iterate through each character in the string.
2. Compare each character with the target character.
3. Increment the count if a match is found.
4. Return the final count.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func countCharOccurrences(str string, char rune) int {
      count := 0
      for i := 0; i < len(str); i++ {
          if rune(str[i]) == char {
              count++
          }
      }
      return count
  }

  func main() {
      str := "hello world"
      char := 'l'
      fmt.Println(countCharOccurrences(str, char))
  }
#+end_src
**** Graphical output
[[./img/c4ai-command-r-plus/string-manipulation/char-occurrence.png]]
**** Prefix domain analysis
- `str`: The input string remains unchanged. The prefix domain indicates the presence of substrings starting from the beginning of the string.
- `char`: The target character, a single rune. In the prefix domain, it represents the character to be matched against the initial segments of `str`.
- `count`: The variable to store the occurrence count, starting from 0 and increasing. The prefix domain shows the progression of counts as the string is processed.
- `i`: Used to iterate over the string. The prefix domain captures the substring from `0` to `i`.
**** Suffix domain analysis
- `str`: The input string remains unchanged. The suffix domain indicates the presence of substrings ending at different points in the string.
- `char`: The target character, a single rune. In the suffix domain, it represents the character to be matched against the final segments of `str`.
- `count`: The variable to store the occurrence count, starting from 0 and increasing. The suffix domain shows the progression of counts as the string is processed.
- `i`: Used to iterate over the string. The suffix domain captures the substring from `i` to the end.
*** Uppercase conversion
The uppercase conversion algorithm converts each character in a string to its uppercase equivalent. The key steps are:
1. Initialize a byte slice to hold the uppercase characters.
2. Iterate through each character in the string.
3. Convert each character to uppercase and store it in the byte slice.
4. Return the resulting uppercase string.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
      "strings"
  )

  func makeUppercase(str string, length int) string {
      upper := make([]byte, length)
      for i := 0; i < length; i++ {
          upper[i] = byte(strings.ToUpper(string(str[i]))[0])
      }
      return string(upper)
  }

  func main() {
      str := "ciao"
      fmt.Println(makeUppercase(str, len(str)))
  }
#+end_src
**** Graphical output
[[./img/c4ai-command-r-plus/string-manipulation/uppercase.png]]
**** Prefix domain analysis
- `str`: The input string remains unchanged. The prefix domain indicates the presence of substrings starting from the beginning of the string.
- `length`: The length of the string, which is fixed. The prefix domain represents the length of the substring being processed.
- `upper`: The byte slice to store uppercase characters. In the prefix domain, it shows the progression of uppercase characters as the string is processed.
- `i`: Used to iterate over the string. The prefix domain captures the substring from `0` to `i`.
**** Suffix domain analysis
- `str`: The input string remains unchanged. The suffix domain indicates the presence of substrings ending at different points in the string.
- `length`: The length of the string, which is fixed. The suffix domain represents the length of the substring being processed.
- `upper`: The byte slice to store uppercase characters. In the suffix domain, it shows the progression of uppercase characters as the string is processed.
- `i`: Used to iterate over the string. The suffix domain captures the substring from `i` to the end.
*** Words count
The word count algorithm splits a string into words and returns the number of words. The key steps are:
1. Use `strings.Fields` to split the string by whitespace.
2. Return the length of the resulting slice, which represents the number of words.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
      "strings"
  )

  func countWords(str string) int {
      words := strings.Fields(str)
      return len(words)
  }

  func main() {
      str := "the house is white"
      fmt.Println(countWords(str))
  }
#+end_src
**** Graphical output
[[./img/c4ai-command-r-plus/string-manipulation/words.png]]
**** Prefix domain analysis
- `str`: The input string remains unchanged. The prefix domain indicates the presence of substrings starting from the beginning of the string.
- `words`: The slice of words obtained by splitting `str`. In the prefix domain, it shows the progression of word accumulation as the string is processed.
- `count`: The length of the `words` slice. In the prefix domain, it represents the count of words identified from the start of the string up to the current position.
**** Suffix domain analysis
- `str`: The input string remains unchanged. The suffix domain indicates the presence of substrings ending at different points in the string.
- `words`: The slice of words obtained by splitting `str`. In the suffix domain, it shows the progression of word accumulation as the string is processed.
- `count`: The length of the `words` slice. In the suffix domain, it represents the count of words identified from the current position to the end of the string.

** Custom algorithms
*** Distinct
The algorithm checks if all elements in an array are distinct.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func areDistinct(arr []int) bool {
      for i := 0; i < len(arr); i++ {
          for j := i + 1; j < len(arr); j++ {
              if arr[i] == arr[j] {
                  return false
              }
          }
      }
      return true
  }

  func main() {
      arr1 := []int{1, 2, 3, 4, 5}
      fmt.Println(areDistinct(arr1))
  }
#+end_src
**** Graphical output
[[./img/c4ai-command-r-plus/custom/distinct.png]]
**** Taint domain analysis
- **Source**: No external user input, array is defined within the program.
- **Sink**: `fmt.Println` - Outputs the result of `areDistinct`, no risk of tainted data.
- **Sanitizer**: Not applicable, no tainted data.
**** Signs domain analysis
- `arr[i]`: Can be any integer. Sign depends on array values.
- `arr[j]`: Can be any integer. Sign depends on array values.
- `i`: Starts at 0 and increments up to `len(arr) - 1`. Sign is non-negative ({0, +}).
- `j`: Starts at `i + 1` and increments up to `len(arr)`. Sign is non-negative and greater than `i` ({0, +}).
- Return value: Boolean indicating distinct elements. Sign domain not applicable for boolean values.

*** Alphabetic check
The script checks if all characters in a string are alphabetic.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
      "unicode"
  )

  func isAlphabetic(s string) bool {
      for _, c := range s {
          if !unicode.IsLetter(c) {
              return false
          }
      }
      return true
  }

  func main() {
      fmt.Println(isAlphabetic("hello"))
  }
#+end_src
**** Graphical output
[[./img/c4ai-command-r-plus/custom/is-alphabetic.png]]
**** Taint domain analysis
- **Source**: The string "hello" is directly defined within the program.
- **Sink**: `fmt.Println` - Outputs the result of `isAlphabetic`, no risk of tainted data.
- **Sanitizer**: Not applicable, no tainted data.
**** Signs domain analysis
- `s`: Input string. The analysis checks each character.
- `c`: Iterates over each character in `s`. Each `c` is a rune, sign domain not applicable.
- Return value: Boolean indicating if all characters are alphabetic. Sign domain not applicable for boolean values.
*** Merge sort
The merge sort algorithm is a classic divide-and-conquer algorithm used for sorting an array or list of elements. Hereâ€™s a detailed overview of how it works:
1. **Divide**: The algorithm divides the input array into two halves. This division continues recursively until each sub-array contains only one element, which is inherently sorted.
2. **Conquer**: The algorithm then merges the sub-arrays back together in a sorted order. This merging process ensures that the combined array is sorted.
3. **Combine**: Finally, the algorithm combines the sub-arrays to form the sorted array.

The merging process involves comparing the elements of the sub-arrays and arranging them in the correct order. The algorithm continues this process until the entire array is sorted. Merge sort is known for its stable sorting and O(n log n) time complexity.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func mergeSort(arr []int) []int {
      if len(arr) <= 1 {
          return arr
      }
      mid := len(arr) / 2
      left := mergeSort(arr[:mid])
      right := mergeSort(arr[mid:])
      return merge(left, right)
  }

  func merge(left []int, right []int) []int {
      result := []int{}
      i, j := 0, 0
      for i < len(left) && j < len(right) {
          if left[i] < right[j] {
              result = append(result, left[i])
              i++
          } else {
              result = append(result, right[j])
              j++
          }
      }
      result = append(result, left[i:]...)
      result = append(result, right[j:]...)
      return result
  }

  func main() {
      arr := []int{3, 1, 4, 1, 5, 9, 2}
      fmt.Println(mergeSort(arr))
  }
#+end_src
**** Graphical output
#+CAPTION: Merge function
[[./img/c4ai-command-r-plus/custom/merge.png]]
#+CAPTION: Mergesort function
[[./img/c4ai-command-r-plus/custom/mergesort.png]]
**** Taint domain analysis
- **Source**: `arr` initialized within `main`.
- **Sink**: `fmt.Println` outputs the result of `mergeSort`.
- **Sanitizer**: Not applicable as there is no external tainted data.

**** Signs domain analysis
- `arr`: Contains integers with a range of values.
- `mid`: Index computed as `len(arr) / 2`, always non-negative.
- `left`: Sub-array of `arr` from index 0 to `mid`.
- `right`: Sub-array of `arr` from `mid` to end.
- `result`: Merged and sorted array, built incrementally.
- `i, j`: Indices used in merging, non-negative and incremented within bounds.

* Second model: zephyr-orpo-141b-A35b-v0.1
** Array manipulation
*** Binary search
*** Count unique elements
*** Occurrence count
** Sorting
*** Count sort
*** Heap sort
*** Insertion sort
** String manipulation
*** Chars occurrence
*** Uppercase
*** Words
** Custom algorithms
*** Distinct
*** Letters
*** Merge sort
* Models comparison
* Final considerations
