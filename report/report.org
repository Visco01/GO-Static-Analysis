#+title: SCRS 2024 final task
#+author: Pietro Visconti
#+SETUPFILE: /Users/visco/.config/doom/latex-standard-setup.org

#+LATEX: \newpage
* Introduction
This project involves the generation and analysis of algorithm implementations
in the GO programming language, leveraging generative AI models. The primary
objective is to evaluate the quality and correctness of the generated GO code
through static analysis using the LiSA tool. The focus is on understanding the
behavior of the code with respect to two specific analysis domains chosen from a
set of available domains.

** Objectives
*** Algorithm Specification and Generation
1. A given amount of algorithm specifications will be assigned across various
   categories such as array manipulation, sorting, and string manipulation.
2. For each specification, two generative AI language models will be used to
   produce the corresponding GO code.
*** Generative AI Models
1. The models selected for this task are:
   - *CohereForAI/c4ai-command-r-plus*
   - *HuggingFaceH4/zephyr-orpo-141b-A35b-v0.1*
2. These models will generate the GO code based on provided specifications.
*** Static Analysis with LiSA
1. Each generated GO code will be analyzed using LiSA to evaluate its behavior
   in two chosen domains. The available domains are signs, parity, intervals,
   pentagons, prefix, suffix, tarsis, and taint.
2. The selected domains for this analysis will focus on understanding how the
   algorithms handle numerical and behavioral properties.
*** Result Investigation
1. The results from LiSA will be thoroughly investigated to identify potential
   issues such as logical errors, out-of-bound accesses, incorrect handling of
   numerical properties, and other relevant concerns.
2. If the analysis is not meaningful due to missing main functions or other
   context-specific code, the models will be prompted to generate complete
   examples including main functions to ensure comprehensive analysis.

** Detailed steps of execution
Once the algorithms are generated through the chosen models:
*** Running LiSA Analysis
1. LiSA will be used to perform static analysis on each generated GO script.
2. Two suitable domains for each algorithm will be selected to provide a comprehensive
   understanding of the code’s behavior.
3. The analysis process and results for each script will be documented.
*** Investigation and Report Writing
1. The results from LiSA will be carefully investigated.
2. The findings will be compilated into a coherent and detailed report, highlighting key insights and any issues detected during the analysis.

#+LATEX: \newpage
* Domains involved into the report

In the context of static analysis for software verification and security, various abstract domains are employed to capture specific properties of programs. Each domain focuses on a particular aspect of the program’s behavior or structure. This section introduces the domains used in our analyses: Intervals, Signs, Parity, Prefix, Suffix, and Taint.

** Intervals Domain
   The Intervals domain is used to determine the range of values that a variable can take. This domain is particularly useful for verifying array bounds, avoiding overflows, and ensuring that variables remain within acceptable limits.

   - *Definition*: Each variable is associated with an interval [a, b], where 'a' and 'b' are the minimum and maximum values the variable can take, respectively.
   - *Example*: For a variable `x` with an interval [0, 10], `x` can take any value between 0 and 10.

** Signs Domain
   The Signs domain focuses on the sign of numerical variables, which can be positive, negative, or zero. This domain is crucial for reasoning about conditional branches and ensuring that certain operations (e.g., division) are safe.

   - *Definition*: Variables are associated with a set of possible signs: {+, -, 0}.
   - *Example*: For a variable `y` that can be either positive or zero, the sign domain would be {+, 0}.

** Parity Domain
   The Parity domain deals with the evenness or oddness of integer values. This domain is useful for optimizations and ensuring correct behavior in algorithms that depend on the parity of numbers.

   - *Definition*: Variables are categorized as even, odd, or unknown (TOP).
   - *Example*: For a variable `z` that is always even, the parity domain would represent it as even.

** Prefix Domain
   The Prefix domain is used in string manipulation analyses to track possible prefixes of string variables. This domain helps in understanding how strings evolve and in ensuring the correctness of string operations.

   - *Definition*: A variable is associated with a set of possible prefixes.
   - *Example*: For a string variable `s` that can start with "abc" or "def", the prefix domain would include these prefixes.

** Suffix Domain
   The Suffix domain, similar to the Prefix domain, tracks possible suffixes of string variables. This domain is important for ensuring the correctness of operations that manipulate the ends of strings.

   - *Definition*: A variable is associated with a set of possible suffixes.
   - *Example*: For a string variable `t` that can end with "xyz" or "uvw", the suffix domain would include these suffixes.

** Taint Domain
   The Taint domain is used for information flow analysis to detect if data from untrusted sources (tainted data) can reach critical points (sinks) in the program without proper sanitization. This domain is essential for security analyses to prevent vulnerabilities like SQL injection and cross-site scripting (XSS).

   - *Definition*: Variables are marked as tainted or untainted based on their origin and the operations performed on them.
   - *Example*: A variable `userInput` read from user input would be marked as tainted, while a variable `sanitizedInput` that has been properly sanitized would be marked as untainted.

** Graphical Representations
   Each domain’s analysis results are represented graphically by LiSA to provide a clear and concise view of the program’s properties. These graphical outputs help in understanding the flow and state changes of variables throughout the program.

---

With this foundational understanding of the analysis domains, let's proceed to the detailed analysis of various algorithms, leveraging these domains to ensure correctness, security, and reliability.

#+LATEX: \newpage
* First AI model: c4ai-command-r-plus
** Array manipulation
The static analysis for the generated GO code using the LiSA tool was conducted with two domains: *Signs* and *Intervals*.
*** Binary search
The binary search algorithm is an efficient method for finding an element within a *sorted array*. It operates by repeatedly dividing the search interval in half. The key steps of this implementation are:
1. Initialize `left` to 0 and `right` to the last index of the array.
2. Calculate `mid` as the average of `left` and `right`.
3. If the middle element `arr[mid]` is equal to the target, return the index `mid`.
4. If `arr[mid]` is less than the target, adjust `left` to `mid + 1`.
5. If `arr[mid]` is greater than the target, adjust `right` to `mid - 1`.
6. Repeat steps 2-5 until `left` exceeds `right`, at which point the target is not present in the array, and return -1.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func binarySearch(arr []int, target int) int {
      left, right := 0, len(arr)-1
      for left <= right {
          mid := (left + right) / 2
          if arr[mid] == target {
              return mid
          } else if arr[mid] < target {
              left = mid + 1
          } else {
              right = mid - 1
          }
      }
      return -1
  }

  func main() {
      arr := []int{1, 2, 3, 4, 5}
      target := 4
      index := binarySearch(arr, target)
      fmt.Println(index)
  }
#+end_src

**** Graphical Output
[[./img/c4ai-command-r-plus/array-manipulation/binary-search.png]]
**** Intervals Domain analysis
- `arr`: The array is not modified, hence its elements remain as [1, 2, 3, 4, 5].
- `left`: Initially set to 0 and adjusted upwards, so the range is [0, 5].
- `right`: Initially set to 4 and adjusted downwards, so the range is [-2, 4].
- `mid`: Calculated as (left + right) / 2, so it depends on the ranges of `left` and `right`.
- `target`: Fixed at 4, so the range is [4, 4].

**** Signs Domain analysis
- `arr`: Not applicable as the domain focuses on numerical values.
- `left`: As `left` is incremented from 0, it remains positive or zero, so the sign is {0, +}.
- `right`: Starts at 4 and decrements, potentially becoming negative, so the sign is {0, +, -}.
- `mid`: Calculated as (left + right) / 2, can be positive or zero, so the sign is {0, +}.
- `target`: Fixed at 4, thus positive, so the sign is {+}.

*** Occurrence count
The occurrence count algorithm iterates through an array and counts the number of times a target value appears. The key steps are:
1. Initialize `count` to 0.
2. Iterate over each element in the array `arr`.
3. For each element `num`, check if it is equal to `target`.
4. If `num` equals `target`, increment `count`.
5. Return the value of `count` after the loop completes.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func occurrenceCount(arr []int, target int) int {
      count := 0
      for _, num := range arr {
          if num == target {
              count++
          }
      }
      return count
  }

  func main() {
      arr := []int{1, 2, 2, 3, 2, 4, 2, 5}
      target := 2
      fmt.Println(occurrenceCount(arr, target))
  }
#+end_src

**** Graphical Output
[[./img/c4ai-command-r-plus/array-manipulation/occurrence-count.png]]

**** Intervals Domain analysis
- `arr`: The array is not modified, hence its elements remain as [1, 2, 2, 3, 2, 4, 2, 5].
- `count`: Initially set to 0 and increments each time a match is found. The range depends on the number of matches, so it is [0, 8].
- `num`: Each element of the array `arr`, so the range is [1, 5].
- `target`: Fixed at 2, so the range is [2, 2].

**** Signs Domain analysis
- `arr`: Not applicable as the domain focuses on numerical values.
- `count`: Starts at 0 and increments, so the sign is {0, +}.
- `num`: Takes values from the array, which are positive, so the sign is {+}.
- `target`: Fixed at 2, thus positive, so the sign is {+}.

*** Count unique elements
The count unique elements algorithm utilizes a map to track unique values as it iterates through the array. The key steps are as follows:
1. Initialize a map `uniqueMap` to keep track of unique numbers.
2. Iterate over each element in the array `arr`.
3. For each element `num`, add it to `uniqueMap` with a value of `true`.
4. Return the number of unique keys in `uniqueMap` using `len()`.

**** Generated code
#+begin_src go
package main

import (
	"fmt"
)

func countUniqueElements(arr []int) int {
	uniqueMap := make(map[int]bool)
	for _, num := range arr {
		uniqueMap[num] = true
	}
	return len(uniqueMap)
}

func main() {
	arr := []int{1, 2, 2, 3, 4, 4, 5}
	fmt.Println(countUniqueElements(arr))
}
#+end_src
**** Graphical output
[[./img/c4ai-command-r-plus/array-manipulation/count-unique-elements.png]]

**** Intervals domain analysis
- `arr`: The input array can contain both unique and duplicate elements; in
  this case, it is `[1, 2, 2, 3, 4, 4, 5]`.
- `uniqueMap`: This map will contain only unique elements; thus, its length
  will vary depending on the number of unique elements found.
- Return Value: The function returns the count of unique elements, which
  ranges from `[0, n]`, where `n` is the length of the input array.

**** Signs domain analysis
- `arr`: Contains integers which can be both positive and negative, or zero,
  hence signs it TOP.
- `uniqueMap`: Not directly applicable as it stores unique keys.
- Return Value: The return value represents the count of unique integers and
  is always non-negative, so the sign set is {0, +}.

** Sorting
The static analysis for the generated GO code using the LiSA tool was conducted with two domains: *Parity* and *Intervals*.
*** Count sort
The count sort algorithm sorts an array by counting the occurrences of each unique value. The key steps are:
1. Find the maximum value in the array to determine the size of the count array.
2. Initialize a count array with zeros.
3. Count the occurrences of each element in the original array.
4. Use the count array to construct the sorted array.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func countSort(arr []int) []int {
      maxVal := 0
      for _, num := range arr {
          if num > maxVal {
              maxVal = num
          }
      }

      count := make([]int, maxVal+1)
      for _, num := range arr {
          count[num]++
      }

      sortedIndex := 0
      for i, freq := range count {
          for j := 0; j < freq; j++ {
              arr[sortedIndex] = i
              sortedIndex++
          }
      }

      return arr
  }

  func main() {
      arr := []int{2, 5, 3, 7, 2, 3, 6}
      fmt.Println(countSort(arr))
  }
#+end_src

**** Graphical output
[[./img/c4ai-command-r-plus/sorting/count-sort.png]]
**** Intervals domain analysis
- `arr`: The array is modified, and its elements are sorted. The initial range is [2, 7].
- `maxVal`: Initially set to 0 and updated to the maximum value in `arr`. The range is [0, 7].
- `count`: Array created with a size of `maxVal+1`, elements incremented based on occurrences in `arr`. Each element's range is [0, 3].
- `sortedIndex`: Used to insert elements into `arr`, incremented from 0. The range is [0, 7].
- `num`: Each element of the array `arr`, so the range is [2, 7].
- `i`: Index for iterating over `count`, ranging from 0 to `maxVal`. The range is [0, 7].
- `freq`: The value from the count array, representing the frequency of `i` in the original array. The range is [0, 3].
- `j`: Iterates from 0 to `freq`, ranges from [0, 3].

**** Parity domain analysis
- `arr`: Not applicable as the domain focuses on numerical values.
- `maxVal`: Represents the maximum value from `arr`, always positive. The parity is even or odd depending on `maxVal`.
- `count`: Elements incremented based on occurrences in `arr`. Values can be even or odd.
- `sortedIndex`: Increments from 0. The parity is {even}.
- `num`: Takes values from the array, either even or odd.
- `i`: Index iterating over `count`, can be even or odd.
- `freq`: The value from the count array, representing the frequency of `i`. Can be even or odd.
- `j`: Iterates from 0 to `freq`, parity depends on `freq`.

*** Heap sort
Heap sort is a comparison-based sorting algorithm that utilizes a binary heap data structure. The key steps are:
1. Build a max heap from the input data.
2. Swap the root of the heap with the last element of the heap.
3. Reduce the heap size by one and call `heapify` on the root.
4. Repeat steps 2-3 until the heap is reduced to a single element.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func heapify(arr []int, N int, i int) {
      largest := i
      left := 2*i + 1
      right := 2*i + 2

      if left < N && arr[left] > arr[largest] {
          largest = left
      }

      if right < N && arr[right] > arr[largest] {
          largest = right
      }

      if largest != i {
          arr[i], arr[largest] = arr[largest], arr[i]
          heapify(arr, N, largest)
      }
  }

  func heapSort(arr []int) {
      N := len(arr)

      for i := N / 2; i >= 0; i-- {
          heapify(arr, N, i)
      }

      for i := N - 1; i > 0; i-- {
          arr[i], arr[0] = arr[0], arr[i]
          heapify(arr, i, 0)
      }
  }

  func main() {
      arr := []int{12, 11, 13, 5, 6, 7}
      heapSort(arr)
      fmt.Println(arr)
  }
#+end_src
**** Graphical output
#+CAPTION: Main heapsort function
[[./img/c4ai-command-r-plus/sorting/heap-sort-heapsort.png]]

#+CAPTION: Heapify function
[[./img/c4ai-command-r-plus/sorting/heap-sort-heapify.png]]
**** Intervals domain analysis
- `arr`: The array is modified during heap construction and sorting. The initial range is [5, 13].
- `N`: Represents the length of the array, fixed at 6. The range is [6, 6].
- `i`: Used in the loops for building and sorting the heap. The range is [0, 6].
- `largest`: Used to track the largest value during heapify, varies between 0 and `N-1`. The range is [0, 6].
- `left`: Calculated as 2*i + 1, ranges from 1 to 13. The range is [1, 13].
- `right`: Calculated as 2*i + 2, ranges from 2 to 14. The range is [2, 14].
**** Parity domain analysis
- `arr`: Not applicable as the domain focuses on numerical values.
- `N`: Fixed at 6, hence the parity is even.
- `i`: Used in the loops, varies from 0 to `N-1`, hence the parity is {even, odd}.
- `largest`: Tracks the largest value during heapify, varies between 0 and `N-1`, hence the parity is {even, odd}.
- `left`: Calculated as 2*i + 1, hence the parity is {odd}.
- `right`: Calculated as 2*i + 2, hence the parity is {even}.
*** Insertion sort
Insertion sort is a simple and intuitive sorting algorithm that builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. The key steps are:
1. Iterate from the second element to the end of the array.
2. For each element, compare it with the elements before it and insert it into its correct position by shifting elements as necessary.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func insertionSort(arr []int) {
      for i := 1; i < len(arr); i++ {
          key := arr[i]
          j := i - 1
          for j >= 0 && arr[j] > key {
              arr[j+1] = arr[j]
              j--
          }
          arr[j+1] = key
      }
  }

  func main() {
      arr := []int{12, 11, 13, 5, 6}
      insertionSort(arr)
      fmt.Println(arr)
  }
#+end_src

**** Graphical output
[[./img/c4ai-command-r-plus/sorting/insertion-sort.png]]
**** Intervals domain analysis
- `arr`: The array is modified during sorting. The initial range is [5, 13].
- `i`: Used to iterate from 1 to the end of the array. The range is [1, 5].
- `key`: Takes the value of `arr[i]` during each iteration. The range is [5, 13].
- `j`: Used to iterate backwards from `i-1` to 0. The range is [0, 4].
**** Parity domain analysis
- `arr`: Not applicable as the domain focuses on numerical values.
- `i`: Used in the loop, varies from 1 to len(arr)-1, hence the parity is {odd}.
- `key`: Takes values from the array, can be either even or odd.
- `j`: Used to iterate backwards from `i-1` to 0, hence the parity is {even, odd}.
** String manipulation
The static analysis for the generated GO code using the LiSA tool was conducted with two domains: *Prefix* and *Suffix*.
*** Chars occurrences
The character occurrences algorithm counts the number of times a specific character appears in a string. The key steps are:
1. Iterate through each character in the string.
2. Compare each character with the target character.
3. Increment the count if a match is found.
4. Return the final count.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func countCharOccurrences(str string, char rune) int {
      count := 0
      for i := 0; i < len(str); i++ {
          if rune(str[i]) == char {
              count++
          }
      }
      return count
  }

  func main() {
      str := "hello world"
      char := 'l'
      fmt.Println(countCharOccurrences(str, char))
  }
#+end_src
**** Graphical output
[[./img/c4ai-command-r-plus/string-manipulation/char-occurrence.png]]
**** Prefix domain analysis
- `str`: The input string remains unchanged. The prefix domain indicates the presence of substrings starting from the beginning of the string.
- `char`: The target character, a single rune. In the prefix domain, it represents the character to be matched against the initial segments of `str`.
- `count`: The variable to store the occurrence count, starting from 0 and increasing. The prefix domain shows the progression of counts as the string is processed.
- `i`: Used to iterate over the string. The prefix domain captures the substring from `0` to `i`.
**** Suffix domain analysis
- `str`: The input string remains unchanged. The suffix domain indicates the presence of substrings ending at different points in the string.
- `char`: The target character, a single rune. In the suffix domain, it represents the character to be matched against the final segments of `str`.
- `count`: The variable to store the occurrence count, starting from 0 and increasing. The suffix domain shows the progression of counts as the string is processed.
- `i`: Used to iterate over the string. The suffix domain captures the substring from `i` to the end.
*** Uppercase conversion
The uppercase conversion algorithm converts each character in a string to its uppercase equivalent. The key steps are:
1. Initialize a byte slice to hold the uppercase characters.
2. Iterate through each character in the string.
3. Convert each character to uppercase and store it in the byte slice.
4. Return the resulting uppercase string.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
      "strings"
  )

  func makeUppercase(str string, length int) string {
      upper := make([]byte, length)
      for i := 0; i < length; i++ {
          upper[i] = byte(strings.ToUpper(string(str[i]))[0])
      }
      return string(upper)
  }

  func main() {
      str := "ciao"
      fmt.Println(makeUppercase(str, len(str)))
  }
#+end_src
**** Graphical output
[[./img/c4ai-command-r-plus/string-manipulation/uppercase.png]]
**** Prefix domain analysis
- `str`: The input string remains unchanged. The prefix domain indicates the presence of substrings starting from the beginning of the string.
- `length`: The length of the string, which is fixed. The prefix domain represents the length of the substring being processed.
- `upper`: The byte slice to store uppercase characters. In the prefix domain, it shows the progression of uppercase characters as the string is processed.
- `i`: Used to iterate over the string. The prefix domain captures the substring from `0` to `i`.
**** Suffix domain analysis
- `str`: The input string remains unchanged. The suffix domain indicates the presence of substrings ending at different points in the string.
- `length`: The length of the string, which is fixed. The suffix domain represents the length of the substring being processed.
- `upper`: The byte slice to store uppercase characters. In the suffix domain, it shows the progression of uppercase characters as the string is processed.
- `i`: Used to iterate over the string. The suffix domain captures the substring from `i` to the end.
*** Words count
The word count algorithm splits a string into words and returns the number of words. The key steps are:
1. Use `strings.Fields` to split the string by whitespace.
2. Return the length of the resulting slice, which represents the number of words.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
      "strings"
  )

  func countWords(str string) int {
      words := strings.Fields(str)
      return len(words)
  }

  func main() {
      str := "the house is white"
      fmt.Println(countWords(str))
  }
#+end_src
**** Graphical output
[[./img/c4ai-command-r-plus/string-manipulation/words.png]]
**** Prefix domain analysis
- `str`: The input string remains unchanged. The prefix domain indicates the presence of substrings starting from the beginning of the string.
- `words`: The slice of words obtained by splitting `str`. In the prefix domain, it shows the progression of word accumulation as the string is processed.
- `count`: The length of the `words` slice. In the prefix domain, it represents the count of words identified from the start of the string up to the current position.
**** Suffix domain analysis
- `str`: The input string remains unchanged. The suffix domain indicates the presence of substrings ending at different points in the string.
- `words`: The slice of words obtained by splitting `str`. In the suffix domain, it shows the progression of word accumulation as the string is processed.
- `count`: The length of the `words` slice. In the suffix domain, it represents the count of words identified from the current position to the end of the string.

** Custom algorithms
*** Distinct
The algorithm checks if all elements in an array are distinct.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func areDistinct(arr []int) bool {
      for i := 0; i < len(arr); i++ {
          for j := i + 1; j < len(arr); j++ {
              if arr[i] == arr[j] {
                  return false
              }
          }
      }
      return true
  }

  func main() {
      arr1 := []int{1, 2, 3, 4, 5}
      fmt.Println(areDistinct(arr1))
  }
#+end_src
**** Graphical output
[[./img/c4ai-command-r-plus/custom/distinct.png]]
**** Taint domain analysis
- `arr`: Fixed array, not tainted as it doesn’t come from an external input.
- `seen`: Map tracking seen elements, derived from `arr` and not tainted.
- `num`: Each element of `arr`, not tainted as it is fixed.
- `seen[num]`: Check if element has been seen, not tainted since both `seen` and `num` are not tainted.
- `seen[num] = true`: Assignment to map, not tainted as both `seen` and `num` are not tainted.
- Return value: Not tainted since `arr` is not from an external source.
**** Signs domain analysis
- `arr[i]`: Can be any integer. Sign depends on array values.
- `arr[j]`: Can be any integer. Sign depends on array values.
- `i`: Starts at 0 and increments up to `len(arr) - 1`. Sign is non-negative ({0, +}).
- `j`: Starts at `i + 1` and increments up to `len(arr)`. Sign is non-negative and greater than `i` ({0, +}).
- Return value: Boolean indicating distinct elements. Sign domain not applicable for boolean values.

*** Alphabetic check
The script checks if all characters in a string are alphabetic.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
      "unicode"
  )

  func isAlphabetic(s string) bool {
      for _, c := range s {
          if !unicode.IsLetter(c) {
              return false
          }
      }
      return true
  }

  func main() {
      fmt.Println(isAlphabetic("hello"))
  }
#+end_src
**** Graphical output
[[./img/c4ai-command-r-plus/custom/is-alphabetic.png]]
**** Taint domain analysis
- `s`: Fixed string input, not tainted as it doesn't come from an external input.
- `c`: Each character in `s`, derived from a non-tainted source, not tainted.
- `unicode.IsLetter(c)`: Checks if `c` is an alphabetic character, not tainted as `c` is not tainted.
- Return value of `isAlphabetic`: Not tainted since `s` is not from an external source.
**** Signs domain analysis
- `s`: Input string. The analysis checks each character.
- `c`: Iterates over each character in `s`. Each `c` is a rune, sign domain not applicable.
- Return value: Boolean indicating if all characters are alphabetic. Sign domain not applicable for boolean values.
*** Merge sort
The merge sort algorithm is a classic divide-and-conquer algorithm used for sorting an array or list of elements. Here’s a detailed overview of how it works:
1. **Divide**: The algorithm divides the input array into two halves. This division continues recursively until each sub-array contains only one element, which is inherently sorted.
2. **Conquer**: The algorithm then merges the sub-arrays back together in a sorted order. This merging process ensures that the combined array is sorted.
3. **Combine**: Finally, the algorithm combines the sub-arrays to form the sorted array.

The merging process involves comparing the elements of the sub-arrays and arranging them in the correct order. The algorithm continues this process until the entire array is sorted. Merge sort is known for its stable sorting and O(n log n) time complexity.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func mergeSort(arr []int) []int {
      if len(arr) <= 1 {
          return arr
      }
      mid := len(arr) / 2
      left := mergeSort(arr[:mid])
      right := mergeSort(arr[mid:])
      return merge(left, right)
  }

  func merge(left []int, right []int) []int {
      result := []int{}
      i, j := 0, 0
      for i < len(left) && j < len(right) {
          if left[i] < right[j] {
              result = append(result, left[i])
              i++
          } else {
              result = append(result, right[j])
              j++
          }
      }
      result = append(result, left[i:]...)
      result = append(result, right[j:]...)
      return result
  }

  func main() {
      arr := []int{3, 1, 4, 1, 5, 9, 2}
      fmt.Println(mergeSort(arr))
  }
#+end_src
#+LATEX: \newpage
**** Graphical output
#+CAPTION: Merge function
[[./img/c4ai-command-r-plus/custom/merge.png]]

#+CAPTION: Mergesort function
[[./img/c4ai-command-r-plus/custom/mergesort.png]]
**** Taint domain analysis
- `arr`: Fixed array, not tainted as it doesn't come from an external input.
- `mid`: Index derived from `arr`, not tainted.
- `left`: Sub-array derived from `arr`, not tainted.
- `right`: Sub-array derived from `arr`, not tainted.
- `result`: Resultant merged array, not tainted as it's derived from non-tainted sub-arrays.
- `i`: Index for iterating `left`, not tainted.
- `j`: Index for iterating `right`, not tainted.
- `merge(left, right)`: Function call merging two non-tainted arrays, not tainted.
- Return value of `mergeSort`: Not tainted since `arr` is not from an external source.

**** Signs domain analysis
- `arr`: Contains integers with a range of values.
- `mid`: Index computed as `len(arr) / 2`, always non-negative.
- `left`: Sub-array of `arr` from index 0 to `mid`.
- `right`: Sub-array of `arr` from `mid` to end.
- `result`: Merged and sorted array, built incrementally.
- `i, j`: Indices used in merging, non-negative and incremented within bounds.
#+LATEX: \newpage
#+LATEX: \newpage
* Second AI model: zephyr-orpo-141b-A35b-v0.1
** Array manipulation
*** Binary search
1. **Initialization**: Set `low` to the first index and `high` to the last index of the array.
2. **Divide and Conquer**:
   - Calculate `mid` as the average of `low` and `high`.
   - If the middle element `arr[mid]` is equal to the target, return the index `mid`.
   - If `arr[mid]` is less than the target, adjust `low` to `mid + 1`.
   - If `arr[mid]` is greater than the target, adjust `high` to `mid - 1`.
3. **Repeat**: Continue the process until `low` exceeds `high`. If the target is not found, return -1.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func binarySearch(arr []int, target int) int {
      low := 0
      high := len(arr) - 1
      for low <= high {
          mid := (low + high) / 2
          if arr[mid] == target {
              return mid
          } else if arr[mid] < target {
              low = mid + 1
          } else {
              high = mid - 1
          }
      }
      return -1
  }

  func main() {
      arr := []int{1, 2, 3, 4, 5, 6, 7}
      target := 5
      index := binarySearch(arr, target)
      if index == -1 {
          fmt.Println("Element not found in the array.")
      } else {
          fmt.Printf("Element %d found at index %d.\n", target, index)
      }
  }
#+end_src
**** Graphical output
[[./img/zephyr-orpo-141b-A35b-v0.1/array-manipulation/binary-search.png]]
**** Intervals Domain analysis
- `arr`: Sorted array, elements remain within their initial range.
- `low`: Initially 0, incremented up to `high`, range is [0, len(arr) - 1].
- `high`: Initially len(arr) - 1, decremented down to `low`, range is [0, len(arr) - 1].
- `mid`: Calculated as (low + high) / 2, range is [0, len(arr) - 1].
- `target`: Fixed, so range is a single value [target, target].

**** Signs Domain analysis
- `arr`: Array of integers, sign depends on elements.
- `low`: Non-negative, sign is {0, +}.
- `high`: Non-negative, sign is {0, +}.
- `mid`: Non-negative, sign is {0, +}.
- `target`: Depends on input, could be {0, +, -}.
*** Count unique elements
1. **Sorting**: The array is sorted using the `sort.Ints()` function.
2. **Counting Unique Elements**:
   - Initialize `uniqueCount` to 1 since the first element is always unique.
   - Iterate through the sorted array starting from the second element.
   - If the current element is different from the previous element, increment the `uniqueCount`.

This ensures that each unique element is counted exactly once.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
      "sort"
  )

  func countUniqueElements(arr []int) int {
      sort.Ints(arr)
      uniqueCount := 1
      for i := 1; i < len(arr); i++ {
          if arr[i] != arr[i-1] {
              uniqueCount++
          }
      }
      return uniqueCount
  }

  func main() {
      arr := []int{1, 2, 3, 2, 4, 2, 5}
      uniqueCount := countUniqueElements(arr)
      fmt.Printf("There are %d unique elements in the array.\n", uniqueCount)
  }
#+end_src
**** Graphical output
[[./img/zephyr-orpo-141b-A35b-v0.1/array-manipulation/count-unique-elements.png]]
**** Intervals Domain analysis
- `arr`: Initially unsorted, sorted using `sort.Ints()`. Elements are bounded by the array's range.
- `uniqueCount`: Initialized to 1, incremented for each unique element. Range is [1, len(arr)].
- `i`: Iterates from 1 to len(arr) - 1. Range is [1, len(arr) - 1].

**** Signs Domain analysis
- `arr`: Array of integers, sign depends on elements.
- `uniqueCount`: Non-negative, sign is {0, +}.
- `i`: Non-negative, sign is {0, +}.

*** Occurrence count
1. **Initialization**: Set a counter `count` to 0.
2. **Iteration**: Loop through each element in the array.
   - If the current element equals the target, increment the `count`.
3. **Return**: The final count of occurrences.

This ensures that the target element's occurrences are accurately counted.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func countOccurrences(arr []int, target int) int {
      count := 0
      for _, num := range arr {
          if num == target {
              count++
          }
      }
      return count
  }

  func main() {
      arr := []int{1, 2, 3, 2, 4, 2, 5}
      target := 2
      count := countOccurrences(arr, target)
      fmt.Printf("The number %d appears %d times in the array.\n", target, count)
  }
#+end_src
**** Graphical output
[[./img/zephyr-orpo-141b-A35b-v0.1/array-manipulation/occurrence-count.png]]
**** Intervals Domain analysis
- `arr`: Array of integers, values depend on input.
- `target`: Fixed integer value.
- `count`: Initialized to 0, incremented for each match. Range is [0, len(arr)].
- `num`: Each element in `arr`. Range is dependent on `arr`.

**** Signs Domain analysis
- `arr`: Array of integers, sign depends on elements.
- `target`: Fixed integer, sign depends on value.
- `count`: Non-negative, sign is {0, +}.
- `num`: Sign depends on elements in `arr`.
** Sorting
*** Count sort
1. **Find Maximum Value**: Determine the maximum value in the array.
2. **Counting Occurrences**: Create a count array to store the frequency of each element.
3. **Reconstruct Array**: Reconstruct the original array using the count array.

This algorithm ensures that the array is sorted efficiently, especially when the range of input values is known and small.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func countSort(arr []int) {
      max := arr[0]
      for _, num := range arr {
          if num > max {
              max = num
          }
      }
      count := make([]int, max+1)
      for _, num := range arr {
          count[num]++
      }

      index := 0
      for i := 0; i < len(count); i++ {
          for j := 0; j < count[i]; j++ {
              arr[index] = i
              index++
          }
      }
  }

  func main() {
      arr := []int{64, 34, 25, 12, 22, 11, 90}
      countSort(arr)
      fmt.Println("Sorted array:", arr)
  }
#+end_src

**** Graphical output
[[./img/zephyr-orpo-141b-A35b-v0.1/sorting/count-sort.png]]
**** Intervals Domain analysis
- `arr`: Array of integers, values depend on input.
- `max`: The maximum value in the array, range is [max(arr)].
- `count`: Array of integers, size is `max+1`, values range from [0, len(arr)].
- `num`: Each element in `arr`, range is [min(arr), max(arr)].
- `index`: Index for reconstructing the array, range is [0, len(arr)-1].

**** Parity Domain analysis
- `arr`: Array of integers, parity depends on elements.
- `max`: Maximum value, parity depends on `arr`.
- `count`: Array size depends on `max`, parity of each element depends on `arr`.
- `num`: Parity depends on elements in `arr`.
- `index`: Parity is even (initially 0) and alternates as it increments.
*** Heap sort
1. **Building a Max Heap**: Reorder the array into a max heap.
2. **Heapify**: Adjust the heap by ensuring the parent node is always larger than its children.
3. **Extract Elements**: Move the largest element to the end and reduce the heap size, repeating the heapify process until the array is sorted.

Heap sort has a time complexity of O(n log n) and is efficient for large data sets.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func heapify(arr []int, n, i int) {
      largest := i
      left := 2*i + 1
      right := 2*i + 2
      if left < n && arr[left] > arr[largest] {
          largest = left
      }

      if right < n && arr[right] > arr[largest] {
          largest = right
      }

      if largest != i {
          arr[i], arr[largest] = arr[largest], arr[i]
          heapify(arr, n, largest)
      }
  }

  func heapSort(arr []int) {
      n := len(arr)
      for i := n/2 - 1; i >= 0; i-- {
          heapify(arr, n, i)
      }

      for i := n - 1; i >= 0; i-- {
          arr[0], arr[i] = arr[i], arr[0]
          heapify(arr, i, 0)
      }
  }

  func main() {
      arr := []int{64, 34, 25, 12, 22, 11, 90}
      heapSort(arr)
      fmt.Println("Sorted array:", arr)
  }
#+end_src
**** Graphical output
#+CAPTION: Heapify function
[[./img/zephyr-orpo-141b-A35b-v0.1/sorting/heapify.png]]
#+CAPTION: Heapsort function
[[./img/zephyr-orpo-141b-A35b-v0.1/sorting/heapsort.png]]
**** Intervals Domain analysis
- `arr`: Array of integers, values depend on input.
- `n`: Length of the array, range is [0, len(arr)].
- `i`: Index used in loops, range is [0, len(arr)-1].
- `largest`: Index of the largest element, range is [0, len(arr)-1].
- `left`: Left child index, range is [0, 2*(len(arr)-1) + 1].
- `right`: Right child index, range is [0, 2*(len(arr)-1) + 2].

**** Parity Domain analysis
- `arr`: Array of integers, parity depends on elements.
- `n`: Length of the array, parity depends on `arr`.
- `i`: Index used in loops, parity alternates as it increments.
- `largest`: Parity depends on comparisons, can be {even, odd}.
- `left`: Parity alternates as it increments, can be {even, odd}.
- `right`: Parity alternates as it increments, can be {even, odd}.
*** Insertion sort
1. **Initialize**: Start with the first element, as a single-element list is already sorted.
2. **Insert**: Pick the next element and insert it into the sorted part of the array in its correct position.
3. **Shift**: Shift all larger elements one position to the right to make space for the inserted element.

Insertion sort has a time complexity of O(n^2) and is efficient for small data sets or nearly sorted data.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func insertionSort(arr []int) {
      for i := 1; i < len(arr); i++ {
          key := arr[i]
          j := i - 1
          for j >= 0 && arr[j] > key {
              arr[j+1] = arr[j]
              j--
          }
          arr[j+1] = key
      }
  }

  func main() {
      arr := []int{64, 34, 25, 12, 22, 11, 90}
      insertionSort(arr)
      fmt.Println("Sorted array:", arr)
  }
#+end_src

**** Graphical output
[[./img/zephyr-orpo-141b-A35b-v0.1/sorting/insertion-sort.png]]
**** Intervals Domain analysis
- `arr`: Array of integers, values depend on input.
- `i`: Index used in loops, range is [1, len(arr)-1].
- `key`: Element being compared and inserted, value depends on `arr`.
- `j`: Index used in inner loop, range is [-1, len(arr)-2].

**** Parity Domain analysis
- `arr`: Array of integers, parity depends on elements.
- `i`: Index used in loops, parity alternates as it increments.
- `key`: Parity depends on `arr[i]`, can be {even, odd}.
- `j`: Index used in inner loop, parity alternates as it decrements, can be {even, odd}.

** String manipulation
The static analysis for the generated GO code using the LiSA tool was conducted with two domains: *Prefix* and *Suffix*.
*** Chars occurrence
The character occurrence algorithm counts the number of times a specific character appears in a given string. It iterates over each character in the string and increments a counter if the character matches the target character. This algorithm is useful in various text processing tasks where frequency analysis of characters is needed.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func countChar(s string, c rune) int {
      count := 0
      for _, char := range s {
          if rune(char) == c {
              count++
          }
      }
      return count
  }

  func main() {
      s := "hello world"
      c := 'l'
      fmt.Println(countChar(s, c))
  }
#+end_src
**** Graphical output
[[./img/zephyr-orpo-141b-A35b-v0.1/string-manipulation/char-occurrence.png]]
**** Prefix Domain analysis
- `s`: The input string, can have any prefix depending on its content.
- `c`: The character to be counted, fixed as 'l'.
- `char`: Current character in the string, depends on the prefix of `s`.
- `count`: Accumulates the count of occurrences of `c`, prefix indicates the counts seen so far.

**** Suffix Domain analysis
- `s`: The input string, can have any suffix depending on its content.
- `c`: The character to be counted, fixed as 'l'.
- `char`: Current character in the string, depends on the suffix of `s`.
- `count`: Accumulates the count of occurrences of `c`, suffix indicates the remaining counts to be processed.

*** Uppercase
The uppercase conversion algorithm transforms all characters in a given string to their uppercase equivalents. It iterates over each character in the string and converts it using the `ToUpper` function from the `strings` package. This is useful for normalization of text data in various applications.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
      "strings"
  )

  func toUpperCase(s string) string {
      return strings.ToUpper(s)
  }

  func main() {
      s := "ciao"
      fmt.Println(toUpperCase(s))
  }
#+end_src

**** Graphical output
[[./img/zephyr-orpo-141b-A35b-v0.1/string-manipulation/uppercase.png]]
**** Prefix Domain analysis
- `s`: The input string, can have any prefix depending on its content.
- `toUpperCase(s)`: The transformation to uppercase, results in a string where each character of the prefix of `s` is converted to its uppercase equivalent.

**** Suffix Domain analysis
- `s`: The input string, can have any suffix depending on its content.
- `toUpperCase(s)`: The transformation to uppercase, results in a string where each character of the suffix of `s` is converted to its uppercase equivalent.

*** Words
The count words algorithm determines the number of words in a given string. It uses the `strings.Fields` function to split the string by whitespace and returns the length of the resulting slice. This is useful for text processing and analysis tasks where word count is needed.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
      "strings"
  )

  func countWords(s string) int {
      return len(strings.Fields(s))
  }

  func main() {
      s := "the house is white"
      fmt.Println(countWords(s))
  }
#+end_src
**** Graphical output
[[./img/zephyr-orpo-141b-A35b-v0.1/string-manipulation/words.png]]
**** Prefix Domain analysis
- `s`: The input string, can have any prefix consisting of words and whitespace.
- `strings.Fields(s)`: Splits the string by whitespace, so the prefix of `s` is considered until a whitespace is encountered.

**** Suffix Domain analysis
- `s`: The input string, can have any suffix consisting of words and whitespace.
- `strings.Fields(s)`: Splits the string by whitespace, so the suffix of `s` is considered after the last whitespace.

** Custom algorithms
*** Distinct
The isDistinct algorithm checks if all elements in an array are unique. It uses a map to track the elements that have been seen. If any element is seen more than once, it returns false; otherwise, it returns true.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func isDistinct(arr []int) bool {
      seen := make(map[int]bool)
      for _, num := range arr {
          if seen[num] {
              return false
          }
          seen[num] = true
      }
      return true
  }

  func main() {
      arr := []int{1, 2, 3, 4, 5}
      fmt.Println(isDistinct(arr))
  }
#+end_src
**** Graphical output
[[./img/zephyr-orpo-141b-A35b-v0.1/custom/distinct.png]]
**** Taint Domain analysis
- `arr`: Fixed array, not tainted as it doesn't come from an external input.
- `seen`: Map tracking seen elements, derived from `arr` and not tainted.
- `num`: Each element of `arr`, not tainted as it is fixed.
- `seen[num]`: Check if element has been seen, not tainted.
- Return value: Not tainted since `arr` is not from an external source.

**** Signs Domain analysis
- `arr`: Elements are positive integers, so signs are {+}.
- `seen`: Tracks elements, hence signs depend on elements of `arr`.
- `num`: Derived from `arr`, so signs are {+}.
- Return value: Boolean, does not have a sign value but depends on signs of `arr`.

*** Alphabetic check
The isAlphabetic function checks if all characters in a string are alphabetic. It iterates over each character and returns false if any character is not a letter.

**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
      "unicode"
  )

  func isAlphabetic(s string) bool {
      for _, r := range s {
          if !unicode.IsLetter(r) {
              return false
          }
      }
      return true
  }

  func main() {
      fmt.Println(isAlphabetic("helloworld"))
  }
#+end_src
**** Graphical output
[[./img/zephyr-orpo-141b-A35b-v0.1/custom/alphabetic-check.png]]
**** Taint Domain analysis
- `s`: Fixed string, not tainted as it doesn't come from an external input.
- `r`: Each character in `s`, not tainted as `s` is fixed.
- `unicode.IsLetter(r)`: Checks if character is a letter, not tainted.
- Return value: Not tainted since `s` is not from an external source.

**** Signs Domain analysis
- `s`: String type, does not have sign value.
- `r`: Rune type, representing each character, does not have sign value.
- Return value: Boolean, does not have a sign value but depends on characters in `s`.

*** Merge sort
**** Generated code
#+begin_src go
  package main

  import (
      "fmt"
  )

  func mergeSort(arr []int) []int {
      if len(arr) <= 1 {
          return arr
      }

      mid := len(arr) / 2
      left := mergeSort(arr[:mid])
      right := mergeSort(arr[mid:])

      return merge(left, right)
  }

  func merge(left, right []int) []int {
      result := make([]int, 0, len(left)+len(right))

      i, j := 0, 0
      for i < len(left) && j < len(right) {
          if left[i] <= right[j] {
              result = append(result, left[i])
              i++
          } else {
              result = append(result, right[j])
              j++
          }
      }

      result = append(result, left[i:]...)
      result = append(result, right[j:]...)

      return result
  }

  func main() {
      arr := []int{5, 2, 4, 7, 1, 3, 2, 6}
      fmt.Println(mergeSort(arr))
  }
#+end_src
**** Graphical output
#+CAPTION: Merge function
[[./img/zephyr-orpo-141b-A35b-v0.1/custom/merge.png]]
#+CAPTION: Mergesort function
[[./img/zephyr-orpo-141b-A35b-v0.1/custom/mergesort.png]]
**** Taint Domain analysis
- `arr`: Fixed array, not tainted as it doesn't come from an external input.
- `left`, `right`: Slices of `arr`, not tainted as `arr` is fixed.
- `result`: Merged array from `left` and `right`, not tainted since all elements originate from `arr`.
- Return value: Not tainted since `arr` is not from an external source.

**** Signs Domain analysis
- `arr`: Contains integer values, can be positive, negative, or zero (signs: {0, +, -}).
- `mid`: Calculated as len(arr)/2, always positive or zero (signs: {0, +}).
- `left`, `right`: Slices of `arr`, inherit the sign values from `arr` (signs: {0, +, -}).
- `i`, `j`: Indices for iteration, always positive or zero (signs: {0, +}).
- `result`: Merged array, inherits the sign values from `arr` (signs: {0, +, -}).
- Return value: Sorted array, inherits the sign values from `arr` (signs: {0, +, -}).

#+LATEX: \newpage
* Final considerations
